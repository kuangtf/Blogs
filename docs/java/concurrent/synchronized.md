# Synchronized

## 常见问题

- 什么是锁的升级和降级
-  什么是JVM里的偏向锁、轻量级锁、重量级锁
- 不同JDK里的Synchronized的实现

## Synchronized的使用

- 代码块形式：

```java
synchronized (this)    //  这个括号中的对象可以是this，也可以是自定义的 Object
{										 //  还可以是这个类的class对象， 类.class
  			// 同步代码块  
}
```

- 方法形式：

```java
 public synchronized void method() {   //  锁对象默认是this
  			// 同步代码块
 }

 public static synchronized void method() {   // 修饰静态方法，锁就是当前所在的Class类
  			// 同步代码块
 }
```

## Synchronized的原理

- 在解释原理之前，先介绍**monitor**对象，monitor可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每一个Java对象就有一把看不见的锁，称为内部锁或者monitor锁。monitor是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联，同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。synchronized通过monitor来实现线程同步，monitor是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的线程同步。

- 将上面的同步代码块反编译，可以看到有`monitorenter`和`monitorexit`指令（同步方法反编译后有`ACC_SYNCHRONIZED`标志），会让对象在执行时使其锁计数器加1或者减1（每个对象拥有一个计数器，当线程获取该对象锁后，计数器就会加一，释放锁后就会将计数器减一）。每一个对象在同一时间只与一个monitor(锁)相关联，而一个monitor在同一时间只能被一个线程获得，一个对象在尝试获得与这个对象相关联的monitor锁的所有权的时候，monitorenter指令会发生如下3中情况之一：
    - monitor计数器为0，意味着目前还没有被获得，那这个线程就会立刻获得然后把锁计数器+1，一旦+1，别的线程再想获取，就需要等待
    - 如果这个monitor已经拿到了这个锁的所有权，又重入了这把锁，那锁计数器就会累加，变成2，并且随着重入的次数，会一直累加
    - 这把锁已经被别的线程获取了，等待锁释放。（当前锁被放到SynchronizedQueue同步队列中，等待获取锁）
- Synchronized可重入的原理：就是上面这个计数器的原理。

## Synchronized中锁的优化

- 优化原因：由于JDK1.6之前synchronized的实现是基于操作系统的Mutex Lock，但是由于使用Mutex Lock需要将当前线程挂起并从用户态切换到内核态来执行，效率低下，如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长，这也即是JDK1.6之前synchronized效率低下的原因。这种依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”，JDK 6中为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。
- 在讲锁优化之前，先将对象头结构解释一下：Hotspot的对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）：
    - **Mark Word**：默认存储对象的HashCode，分代年龄和锁标志位信息。这些信息都是与对象自身定义无关的数据，所以Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。
    - **Klass Point**：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。

- 目前锁一共有4种状态，级别从低到高依次是：无锁、偏向锁、轻量级锁和重量级锁。锁状态只能升级不能降级。

| **锁状态** | **存储内容**                                            | **存储内容** |
| ---------- | ------------------------------------------------------- | ------------ |
| 无锁       | 对象的hashCode、对象分代年龄、是否是偏向锁（0）         | 01           |
| 偏向锁     | 偏向线程ID、偏向时间戳、对象分代年龄、是否是偏向锁（1） | 01           |
| 轻量级锁   | 指向栈中锁记录的指针                                    | 00           |
| 重量级锁   | 指向互斥量（重量级锁）的指针                            | 10           |

- **无锁**：

    - 无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。无锁无法全面代替有锁，但无锁在某些场合下的性能是非常高的。

- **偏向锁**：

    - 偏向锁的获取：当一个线程访问同步代码块并获取锁时，会在Mark Word里存储锁偏向的线程ID。在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可。
    - 偏向锁的释放：偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态。

    ![](https://gitee.com/kuangtf/blogImage/raw/master/img/synchronized1.jpg)

- **轻量级锁**：

    - 是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。
    - 在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，然后拷贝对象头中的Mark Word复制到锁记录中。
    - 拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象的Mark Word。
    - 如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，表示此对象处于轻量级锁定状态。
    - 如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。
    - 若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。

    ![](https://gitee.com/kuangtf/blogImage/raw/master/img/synchronized2.jpg)

- **重量级锁**：
    - 升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。

- 锁的优缺点对比：

| **锁**   | **优点**                                                     | **缺点**                                                     | **使用场景**                       |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ---------------------------------- |
| 偏向锁   | 加锁和解锁不需要CAS操作，没有额外的性能消耗，和执行非同步方法相比仅存在纳秒级的差距 | 如果线程间存在锁竞争，会带来额外的锁撤销的消耗               | 适用于只有一个线程访问同步快的场景 |
| 轻量级锁 | 竞争的线程不会阻塞，提高了响应速度                           | 如线程成始终得不到锁竞争的线程，使用自旋会消耗CPU性能        | 追求响应时间，同步快执行速度非常快 |
| 重量级锁 | 线程竞争不适用自旋，不会消耗CPU                              | 线程阻塞，响应时间缓慢，在多线程下，频繁的获取释放锁，会带来巨大的性能消耗 | 追求吞吐量，同步快执行速度较长     |

- synchronized执行流程：https://www.processon.com/embed/60fcc598e401fd7e997b219b



> 参考连接：
>
> java并发编程的艺术
>
> [Java全栈](https://www.pdai.tech/md/java/thread/java-thread-x-key-synchronized.html#%E5%B8%A6%E7%9D%80bat%E5%A4%A7%E5%8E%82%E7%9A%84%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%8E%BB%E7%90%86%E8%A7%A3synchronized)
>
> [知乎](https://zhuanlan.zhihu.com/p/29866981)
>
> [美团文章](https://tech.meituan.com/2018/11/15/java-lock.html)

