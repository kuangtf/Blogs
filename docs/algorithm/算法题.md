##  算法进度

| 题型       | 简单 | 中等 | 简单进度 | 中等进度 |
| ---------- | ---- | ---- | -------- | -------- |
| 数组       | 10   | 20   | √        | √        |
| 链表       | 10   | 20   | √        | √        |
| 栈         | 5    | 5    | √        | √        |
| 堆         | 5    | 5    | √        | √        |
| 哈希表     | 10   | 10   | √        | √        |
| 二叉树     | 20   | 30   | √        | √        |
| 分治、回溯 | 10   | 10   | √        | √        |
| DFS、BFS   | 10   | 20   | √        | √        |
| 贪心       | 10   | 20   | √        | √        |
| 二分法     | 10   | 10   | √        | √        |
| 动态规划   | 30   | 30   | √        | √        |
| 排序       | 5    | 5    | √        | √        |
| 字符串     | 20   | 30   | √        | √        |
| 图         | 5    | 5    | √        | √        |

- [ ] 二叉树遍历模板

- 前序遍历

```java
void traverse(TreeNode root) {
    
    // 递归终止条件
    if (root == null) return;
    
    // 前序遍历代码，就是对每个节点需要进行的操作
    ...
        
    // 递归代码
    traverse(root.left);
    traverse(root.right);
    
}
```

- 中序遍历

```java
void traverse(Tree root) {
    
    // 递归终止条件
    if (root == null) return;
    
    // 递归代码
    traverse(root.left);
    
    // 中序遍历代码，就是对每个节点需要进行的操作
    ...
        
    // 递归代码
    traverse(root.right);
}
```

- 后续遍历

```java
void traverse(TreeNode root) {
    
    // 递归终止条件
    if (root == null) return;
    
    // 递归代码
    traverse(root.left);
    traverse(root.right);
    
    // 后续遍历代码，就是对每个节点需要进行的操作
    ...
}
```

- 层级遍历

```java
void traverse(TreeNode root) {
    
    if (root == null) return;
    
    // 初始化队列，将root加入队列
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    
    while (!queue.isEmpty()) {
        TreeNode cur = queue.poll();
        
        // 层级遍历代码位置，就是对每个节点需要进行的操作
        ...
            
        if (cur.left != null) {
            queue.offer(cur.left);
        }
        
        if (cur.right != null) {
            queue.offer(cur.right);
        }
    }
}
```

> 队列queue中不会存在空指针 null 。

- [ ] n 叉树递归模板

- n 叉树前序遍历模板

```java
void traverse(TreeNode root) {
    
    // 递归终止条件
    if (root == null) return;
    
    // 前续遍历代码，就是对每个节点需要进行的操作
    ...
        
    // 递归代码
    for (Node child : root.chiledren) {
        traverse(child);
    }
}
```

- n叉树后续遍历模板

```java
void traverse(TreeNode root) {
    
    // 递归终止条件
    if (root == null) return;
    
    // 递归代码
    for (Node child : root.chiledren) {
        traverse(child);
    }
    
    // 后续遍历代码，就是对每个节点需要进行的操作
    ...
        
}
```

- [ ] BST遍历模板

- 判断BST的合法性

```java
boolean isValidBST(TreeNode root) {
    return isValidBST(root, null, null);
}

// 限定以 root 为根的子树节点必须满足 max.val > root.val > min.val
boolean isValidBST(TreeNode root, TreeNode min, TreeNode max) {
    // base case
    if (root == null) return true;
    // 若 root.val 不符合 max 和 min 的限制，说明不是合法 BST
    if (min != null && root.val <= min.val) return false;
    if (max != null && root.val >= max.val) return false;
    // 限定左子树的最大值是root.val, 右子树的最小值是 root.val
    return isValidBST(root.left, min, root) && isValid(root.right, root, max);
}

// 错误写法
boolean isValidBST(TreeNode root) {
    if (root == null) return true;
    if (root.left != null && root.val <= root.left.val) return false;
    if (root.right != null && root.val >= root.right.val) return false;
    return isValidBST(root.left) && isValidBST(root.right);
}
```
- BST中搜索一个数

```java
void BST(TreeNode root, int target) {
    if (root.val == target) {
        // 找到目标，做点什么
    }
    if (root.val < target) {
        BST(root.right, target);
    }
    if (root.val > target) {
        BST(root.left, target);
    }
}
```

- BST中插入一个数

```java
TreeNode insertIntoBST(TreeNode root, int val) {
    // 找到空位置插入新节点
    if (root == null) {
        return new TreeNode(val);
    }
    if (root.val == val) {
        // BST中一般不会插入已存在元素
    }
    if (root.val < val) {
        root.right = insertIntoBST(root.right, val);
    }
    if (root.val > val) {
        root.left = insertIntoBST(root.left, val);
    }
    return root;
}
```

- BST中删除一个数

```java
TreeNode deleteNode(TreeNode root, int key) {
    if (root == null) return null;
    if (root.val == key) {
        // 这两个if把情况1和情况2都正确处理了
        if (root.left == null) return root.right;
        if (root.right == null) return root.left;
        // 处理情况3
        TreeNode minNode = getMin(root.right);
        root.val = minNode.val;
        root.right = deleteNode(root.right, minNode.val);
    } else if (root.val > key) {
        root.left = deleteNode(root.left, key);
    } else if (root.val < key) {
        root.right = deleteNode(root.right, key);
    }
    return root;
}

TreeNode getMin(TreeNode node ) {
    // BST 最左边的就是最小的
    while (node.left != null) node = node.left;
    return node;
}
```

- [ ] 回溯算法的框架

```java
result = []
def backtrack(路径，选择列表):
	if 满足结束条件：
        result.add(路径)
        return
        
  for 选择 in 选择列表
      做选择
      backtrack(路径，选择列表)
           撤销
```

- [ ] BFS框架

```java
// 计算从起点 start 到终点 target 的最近距离
int BFS(Node start, Node target) {
    Queue<Node> q;   // 核心数据结构
    Set<Node> visited;  // 避免走回头路
    
    q.offer(start);   // 将起点加入队列
    visited.add(start); 
    int step = 0;  // 记录扩展的步数
    
    while (q not empty) {
		int sz = q.size();
        // 将当前队列中的所有节点向四周扩散
        for (int i  = 0; i < sz; i++) {
            Node cur = q.poll();
            // 在这里判断是否达到终点
            if (cur is target)
               	return step;
            // 将cur的相邻节点加入队列
            for (Node x : cur.adj())
                if (x not in visited) {
                    q.offer(x);
                    visited.add(x);
                }
        }
        // 更新步数
        step++
    }
}
```



